<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Xmipp: Fourier Transform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xmipp_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xmipp
   &#160;<span id="projectnumber">v20.07</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fourier Transform</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7416ec40ddb9de01bd24a45cdac77bd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga7416ec40ddb9de01bd24a45cdac77bd7">AmplitudePhaseToRealImaginary</a> (double Am2Re[], double Ph2Im[], long SignalLength)</td></tr>
<tr class="separator:ga7416ec40ddb9de01bd24a45cdac77bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337082315b52573bcbc5189c57b388e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga337082315b52573bcbc5189c57b388e3">DftAmplitudePhaseToAmplitudePhase</a> (double Am2Am[], double Ph2Ph[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga337082315b52573bcbc5189c57b388e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188f78f98060a171816e43303b850e90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga188f78f98060a171816e43303b850e90">DftAmplitudePhaseToRealImaginary</a> (double Am2Re[], double Ph2Im[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga188f78f98060a171816e43303b850e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3953a1bb8f096d0d4b456aecf288fc9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga3953a1bb8f096d0d4b456aecf288fc9f">DftRealImaginaryToAmplitudePhase</a> (double Re2Am[], double Im2Ph[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga3953a1bb8f096d0d4b456aecf288fc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf360d6b373400f943dc4757c77343a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga1bf360d6b373400f943dc4757c77343a">DftRealImaginaryToRealImaginary</a> (double Re2Re[], double Im2Im[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga1bf360d6b373400f943dc4757c77343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d6a2874de910c46a78e2e7292fdfb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gaf3d6a2874de910c46a78e2e7292fdfb0">DftRealToAmplitudePhase</a> (double R2Am[], double PhOut[], double *Tmp, double CaS[], long SignalLength)</td></tr>
<tr class="separator:gaf3d6a2874de910c46a78e2e7292fdfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd5787f982db02a4f7655e7b54f67ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga9fd5787f982db02a4f7655e7b54f67ad">DftRealToRealImaginary</a> (double R2Re[], double ImOut[], double *Tmp, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga9fd5787f982db02a4f7655e7b54f67ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bcead24719e20ae6d170671c012d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga45bcead24719e20ae6d170671c012d8a">GetCaS</a> (double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga45bcead24719e20ae6d170671c012d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977fefa08d7cd2841de1fb955a5d100a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga977fefa08d7cd2841de1fb955a5d100a">InvDftAmplitudePhaseToAmplitudePhase</a> (double Am2Am[], double Ph2Ph[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga977fefa08d7cd2841de1fb955a5d100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584da9b16cd800a183b8ea7ebcd60f05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga584da9b16cd800a183b8ea7ebcd60f05">InvDftAmplitudePhaseToReal</a> (double Am2R[], double PhIn[], double *Tmp, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga584da9b16cd800a183b8ea7ebcd60f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40eff8abe9c82dc6f8af810283d6af8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga40eff8abe9c82dc6f8af810283d6af8c">InvDftAmplitudePhaseToRealImaginary</a> (double Am2Re[], double Ph2Im[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga40eff8abe9c82dc6f8af810283d6af8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3dfad1464e944fdd192eb9850f6de7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gaf3dfad1464e944fdd192eb9850f6de7a">InvDftRealImaginaryToAmplitudePhase</a> (double Re2Am[], double Im2Ph[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:gaf3dfad1464e944fdd192eb9850f6de7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf71187df33f6be15550eb09b0ce8c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga8bf71187df33f6be15550eb09b0ce8c2">InvDftRealImaginaryToReal</a> (double Re2R[], double ImIn[], double *Tmp, double CaS[], long SignalLength)</td></tr>
<tr class="separator:ga8bf71187df33f6be15550eb09b0ce8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf165521cf0058d5d6baf7faaee25a680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gaf165521cf0058d5d6baf7faaee25a680">InvDftRealImaginaryToRealImaginary</a> (double Re2Re[], double Im2Im[], double *TmpRe, double *TmpIm, double CaS[], long SignalLength)</td></tr>
<tr class="separator:gaf165521cf0058d5d6baf7faaee25a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964f3d8f690cbd1b3581e6b641a57cbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga964f3d8f690cbd1b3581e6b641a57cbf">RealImaginaryToAmplitudePhase</a> (double Re2Am[], double Im2Ph[], long SignalLength)</td></tr>
<tr class="separator:ga964f3d8f690cbd1b3581e6b641a57cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f08cb8e86f4c6e3c3b7bb6560f0b942"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga5f08cb8e86f4c6e3c3b7bb6560f0b942">VolumeAmplitudePhaseToRealImaginary</a> (double Am2Re[], double Ph2Im[], long Nx, long Ny, long Nz)</td></tr>
<tr class="separator:ga5f08cb8e86f4c6e3c3b7bb6560f0b942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c784315c77ffd1e2dafb2ce8188d38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga42c784315c77ffd1e2dafb2ce8188d38">VolumeDftAmplitudePhaseToAmplitudePhase</a> (double *Am2Am, double *Ph2Ph, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:ga42c784315c77ffd1e2dafb2ce8188d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8d36eecfd31d3b828aac1ebb662eb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gacc8d36eecfd31d3b828aac1ebb662eb5">VolumeDftAmplitudePhaseToRealImaginary</a> (double *Am2Re, double *Ph2Im, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gacc8d36eecfd31d3b828aac1ebb662eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe88f87de9a0146da82943dc09584dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gadbe88f87de9a0146da82943dc09584dd">VolumeDftRealImaginaryToAmplitudePhase</a> (double *Re2Am, double *Im2Ph, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gadbe88f87de9a0146da82943dc09584dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ce1a9e5a732ccf7fcb99d9e25051e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gac8ce1a9e5a732ccf7fcb99d9e25051e3">VolumeDftRealImaginaryToRealImaginary</a> (double *Re2Re, double *Im2Im, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gac8ce1a9e5a732ccf7fcb99d9e25051e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa717cfb7004714b1f011c4ac857058b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gafa717cfb7004714b1f011c4ac857058b">VolumeDftRealToAmplitudePhase</a> (double *Re2Am, double *PhOut, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gafa717cfb7004714b1f011c4ac857058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f1bc9822cf497b19feedd15be0312f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gaf2f1bc9822cf497b19feedd15be0312f">VolumeDftRealToRealImaginary</a> (double *Re2Re, double *ImOut, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gaf2f1bc9822cf497b19feedd15be0312f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade800fd8ddd2c7c693a8963b21dafd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gaade800fd8ddd2c7c693a8963b21dafd7">VolumeInvDftAmplitudePhaseToAmplitudePhase</a> (double *Am2Am, double *Ph2Ph, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gaade800fd8ddd2c7c693a8963b21dafd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab337314c0bb0ddfae1263af9cf3e8adf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gab337314c0bb0ddfae1263af9cf3e8adf">VolumeInvDftAmplitudePhaseToReal</a> (double *Am2Re, double *PhIn, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gab337314c0bb0ddfae1263af9cf3e8adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2380769da7bbe8247a305dd3d7d5505b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga2380769da7bbe8247a305dd3d7d5505b">VolumeInvDftAmplitudePhaseToRealImaginary</a> (double *Am2Re, double *Ph2Im, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:ga2380769da7bbe8247a305dd3d7d5505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga243dc816c021942a5020adcf23551bdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga243dc816c021942a5020adcf23551bdc">VolumeInvDftRealImaginaryToAmplitudePhase</a> (double *Re2Am, double *Im2Ph, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:ga243dc816c021942a5020adcf23551bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435433488bd47fbcfbc0bd10a5b1ce9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#ga435433488bd47fbcfbc0bd10a5b1ce9e">VolumeInvDftRealImaginaryToReal</a> (double *Re2Re, double *ImIn, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:ga435433488bd47fbcfbc0bd10a5b1ce9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbae2f9dcdbcedd25230b06c32b50816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gacbae2f9dcdbcedd25230b06c32b50816">VolumeInvDftRealImaginaryToRealImaginary</a> (double *Re2Re, double *Im2Im, long Nx, long Ny, long Nz, int *Status)</td></tr>
<tr class="separator:gacbae2f9dcdbcedd25230b06c32b50816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5c4d3b70b30ae0ec73f8dcfef05437"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BilibFourierTransform.html#gafd5c4d3b70b30ae0ec73f8dcfef05437">VolumeRealImaginaryToAmplitudePhase</a> (double Re2Am[], double Im2Ph[], long Nx, long Ny, long Nz)</td></tr>
<tr class="separator:gafd5c4d3b70b30ae0ec73f8dcfef05437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7416ec40ddb9de01bd24a45cdac77bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AmplitudePhaseToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ph2Im</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Amplitude/Phase &ndash;&gt; Real Imaginary. Converts an (amplitude, phase) representation of a complex signal into a (real, imaginary) representation the input phase is in [rad]. in-place processing. The input signal (amplitude Am2Re and phase Ph2Im) is replaced by the output signal (real Am2Re and imaginary Ph2Im) SignalLength is the signal length.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga337082315b52573bcbc5189c57b388e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DftAmplitudePhaseToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ph2Ph</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFT of a complex signal.</p>
<p>Computes the direct DFT of a complex signal given in (amplitude, phase) representation and returns an (amplitude, phase) representation. The input phase is in [rad]. The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (amplitude Am2Am and phase Ph2Ph) is replaced by the output signal (amplitude Am2Am and phase Ph2Ph).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each the values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftAmplitudePhaseToAmplitudePhase returns.</p>
<p>SignalLength is the length of the signal. no restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga188f78f98060a171816e43303b850e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DftAmplitudePhaseToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ph2Im</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFT of a complex signal.</p>
<p>Computes the direct DFT of a complex signal given in (amplitude, phase) representation and returns a (real, imaginary) representation. The input phase is in [rad]. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (amplitude Am2Re and phase Ph2Im) is replaced by the output signal (real Am2Re and imaginary Ph2Im).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. The values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftAmplitudePhaseToRealImaginary returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga3953a1bb8f096d0d4b456aecf288fc9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DftRealImaginaryToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Im2Ph</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFT of a complex signal.</p>
<p>Computes the direct DFT of a complex signal given in (real, imaginary) representation and returns an (amplitude, phase) representation. The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (real Re2Am and imaginary Im2Ph) is replaced by the output signal (amplitude Re2Am and phase Im2Ph).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. The values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftRealImaginaryToAmplitudePhase returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga1bf360d6b373400f943dc4757c77343a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DftRealImaginaryToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Im2Im</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFT of a complex signal.</p>
<p>Computes the direct DFT of a complex signal given in (real, imaginary) representation and returns a (real, imaginary) representation. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (real Re2Re and imaginary Im2Im) is replaced by the output signal (real Re2Re and imaginary Im2Im).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. The values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftRealImaginaryToRealImaginary returns</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="gaf3d6a2874de910c46a78e2e7292fdfb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DftRealToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>PhOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFT of a real signal.</p>
<p>Computes the direct DFT of a real signal and returns an (amplitude, phase) representation. The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. Te input signal (real R2Am) is replaced by the output signal (amplitude R2Am and phase PhOut).</p>
<p>Tmp is a pre-allocated workspace of size SignalLength. The values returned in Tmp are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftRealToAmplitudePhase returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga9fd5787f982db02a4f7655e7b54f67ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DftRealToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ImOut</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFT of a real signal.</p>
<p>Computes the direct DFT of a real signal and returns a (real, imaginary) representation. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (real R2Re) is replaced by the output signal (real R2Re and imaginary ImOut).</p>
<p>Tmp is a pre-allocated workspace of size SignalLength. The values returned in Tmp are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftRealToRealImaginary returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga45bcead24719e20ae6d170671c012d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetCaS </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the CaS array necessary for Fourier transforms.</p>
<p>Computes an array of coefficients of size SignalLength. These coefficients are necessary for performing a Hartley transform. The Hartley transform is an alternate representation of Fourier for real signals. Hartley computations are more accurate (less roundoff errors) than Fourier. The same coefficients are used for direct and inverse transforms.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga977fefa08d7cd2841de1fb955a5d100a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InvDftAmplitudePhaseToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ph2Ph</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse Fourier Transform of a complex signal.</p>
<p>Computes the inverse DFT of a complex signal given in (amplitude, phase) representation and returns an (amplitude, phase) representation. The input phase is in [rad]. The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (amplitude Am2Am and phase Ph2Ph) is replaced by the output signal (amplitude Am2Am and phase Ph2Ph).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. The values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when DftAmplitudePhaseToAmplitudePhase returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga584da9b16cd800a183b8ea7ebcd60f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InvDftAmplitudePhaseToReal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2R</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>PhIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse Fourier Transform of a real signal.</p>
<p>Computes the inverse DFT of a complex signal given in (amplitude, phase) representation and returns a real signal. The complex Fourier signal is symmetrized before the inverse transformation is applied. The input phase is in [rad]. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (amplitude Am2R and phase PhIn) is replaced by the output signal (real Am2R).</p>
<p>Tmp is a pre-allocated workspace of size SignalLength. The values returned in Tmp are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when InvDftAmplitudePhaseToReal returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga40eff8abe9c82dc6f8af810283d6af8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InvDftAmplitudePhaseToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ph2Im</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse Fourier Transform of a complex signal.</p>
<p>Computes the inverse DFT of a complex signal given in (amplitude, phase) representation and returns a (real, imaginary) representation. The input phase is in [rad]. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (amplitude Am2Re and phase Ph2Im) is replaced by the output signal (real Am2Re and imaginary Ph2Im).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. Tthe values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when InvDftAmplitudePhaseToRealImaginary returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="gaf3dfad1464e944fdd192eb9850f6de7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InvDftRealImaginaryToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Im2Ph</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse Fourier Transform for a complex signal.</p>
<p>Computes the inverse DFT of a complex signal given in (real, imaginary) representation and returns an (amplitude, phase) representation. The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (real Re2Am and imaginary Im2Ph) is replaced by the output signal (amplitude Re2Am and phase Im2Ph).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. The values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when InvDftRealImaginaryToAmplitudePhase returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga8bf71187df33f6be15550eb09b0ce8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InvDftRealImaginaryToReal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2R</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ImIn</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse Fourier Transform of a real signal.</p>
<p>Computes the inverse DFT of a complex signal given in (real, imaginary) representation and returns a real signal. The complex Fourier signal is symmetrized before the inverse transformation is applied. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (real Re2R and imaginary ImIn) is replaced by the output signal (real Re2R).</p>
<p>Tmp is a pre-allocated workspace of size SignalLength. The values returned in Tmp are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when InvDftRealImaginaryToReal returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="gaf165521cf0058d5d6baf7faaee25a680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InvDftRealImaginaryToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Im2Im</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TmpIm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>CaS</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse Fourier Transform of a complex signal.</p>
<p>Computes the inverse DFT of a complex signal given in (real, imaginary) representation and returns a (real, imaginary) representation. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd.</p>
<p>The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd.</p>
<p>The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>In-place processing. The input signal (real Re2Re and imaginary Im2Im) is replaced by the output signal (real Re2Re and imaginary Im2Im).</p>
<p>(TmpRe, TmpIm) are pre-allocated workspaces of size SignalLength each. The values returned in (TmpRe, TmpIm) are meaningless.</p>
<p>CaS is an input array of coefficients of size SignalLength (see GetCaS function). CaS is modified internally, but is restored when InvDftRealImaginaryToRealImaginary returns.</p>
<p>SignalLength is the length of the signal. No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga964f3d8f690cbd1b3581e6b641a57cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RealImaginaryToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Im2Ph</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>SignalLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Real/Imaginary &ndash;&gt; Amplitude/Phase.</p>
<p>Converts a (real, imaginary) representation of a complex signal into an (amplitude, phase) representation The output phase is in [rad]; its domain is (-PI, PI).</p>
<p>In-place processing. The input signal (real Re2Am and imaginary Im2Ph) is replaced by the output signal (amplitude Re2Am and phase Im2Ph).</p>
<p>SignalLength is the signal length.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga5f08cb8e86f4c6e3c3b7bb6560f0b942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeAmplitudePhaseToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Am2Re</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ph2Im</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Volume Amplitude/Phase &ndash;&gt; Real/Imaginary. Converts an (amplitude, phase) representation of a complex signal into a (real, imaginary) representation.</p>
<p>The input phase is in [rad]. In-place processing . The input signal (amplitude Am2Re and phase Ph2Im) is replaced by the output signal (real Am2Re and imaginary Ph2Im).</p>
<p>Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
<a class="anchor" id="ga42c784315c77ffd1e2dafb2ce8188d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeDftAmplitudePhaseToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Am2Am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ph2Ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct DFT of a complex signal. Computes the direct DFT of a complex signal given in (amplitude, phase) representation and returns an (amplitude, phase) representation.</p>
<p>The input phase is in [rad]. The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz.</p>
<p>Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (amplitude Am2Am and phase Ph2Ph) is replaced by the output signal (amplitude Am2Am and phase Ph2Ph).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gacc8d36eecfd31d3b828aac1ebb662eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeDftAmplitudePhaseToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Am2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ph2Im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the direct DFT of a complex signal. Computes the direct DFT of a complex signal given in (amplitude, phase) representation and returns a (real, imaginary) representation.</p>
<p>The input phase is in [rad]. The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing, the input signal (amplitude Am2Re and phase Ph2Im) is replaced by the output signal (real Am2Re and imaginary Ph2Im).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gadbe88f87de9a0146da82943dc09584dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeDftRealImaginaryToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Im2Ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the direct DFT of a complex signal. Computes the direct DFT of a complex signal given in (real, imaginary) representation and returns an (amplitude, phase) representation.</p>
<p>The output phase is in [rad]; its domain is (-PI, PI). The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (real Re2Am and imaginary Im2Ph) is replaced by the output signal (amplitude Re2Am and phase Im2Ph).</p>
<p>Success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gac8ce1a9e5a732ccf7fcb99d9e25051e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeDftRealImaginaryToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Im2Im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the direct DFT of a complex signal. Computes the direct DFT of a complex signal given in (real, imaginary) representation and returns a (real, imaginary) representation.</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (real Re2Re and imaginary Im2Im) is replaced by the output signal (real Re2Re and imaginary Im2Ph).</p>
<p>Success: return(!ERROR); failure: return(ERROR);. The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gafa717cfb7004714b1f011c4ac857058b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeDftRealToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>PhOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the direct DFT of a real signal. Computes the direct DFT of a real signal and returns an (amplitude, phase) representation. The output phase is in [rad]; its domain is (-PI, PI).</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal Re2Am is replaced by the output signal (amplitude Re2Am and phase PhOut).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gaf2f1bc9822cf497b19feedd15be0312f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeDftRealToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ImOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the direct DFT of a real signal. Computes the direct DFT of a real signal and returns a (real, imaginary) representation.</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal Re2Re is replaced by the output signal (real Re2Re and imaginary ImOut).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gaade800fd8ddd2c7c693a8963b21dafd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeInvDftAmplitudePhaseToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Am2Am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ph2Ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the inverse DFT of a complex signal. Computes the inverse DFT of a complex signal given in (amplitude, phase) representation and returns an (amplitude, phase) representation. The input phase is in [rad]. The output phase is in [rad]; its domain is (-PI, PI).</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (amplitude Am2Am and phase Ph2Ph) is replaced by the output signal (amplitude Am2Am and phase Ph2Ph).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gab337314c0bb0ddfae1263af9cf3e8adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeInvDftAmplitudePhaseToReal </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Am2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>PhIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the inverse DFT of a complex signal. Computes the inverse DFT of a complex signal given in (amplitude, phase) representation and returns a real signal. The complex Fourier signal is symmetrized before the inverse transformation is applied. The input phase is in [rad]. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (amplitude Am2Re and phase PhIn) is replaced by the output signal (real Am2Re). PhIn is destroyed.</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="ga2380769da7bbe8247a305dd3d7d5505b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeInvDftAmplitudePhaseToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Am2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ph2Im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the inverse DFT of a complex signal. Computes the inverse DFT of a complex signal given in (amplitude, phase) representation and returns a (real, imaginary) representation.</p>
<p>The input phase is in [rad]. The origin is at index [0].</p>
<p>The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (amplitude Am2Re and phase Ph2Im) is replaced by the output signal (real Am2Re and imaginary Ph2Im).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="ga243dc816c021942a5020adcf23551bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeInvDftRealImaginaryToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Im2Ph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the inverse DFT of a complex signal. Computes the inverse DFT of a complex signal given in (real, imaginary) representation and returns an (amplitude, phase) representation. The output phase is in [rad]; its domain is (-PI, PI).</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (real Re2Am and imaginary Im2Ph) is replaced by the output signal (amplitude Re2Am and phase Im2Ph).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="ga435433488bd47fbcfbc0bd10a5b1ce9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeInvDftRealImaginaryToReal </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ImIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the inverse DFT of a complex signal. Computes the inverse DFT of a complex signal given in (real, imaginary) representation and returns a real signal. The complex Fourier signal is symmetrized before the inverse transformation is applied.</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (real Re2Re and imaginary ImIn) is replaced by the output signal (real Re2Re).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gacbae2f9dcdbcedd25230b06c32b50816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeInvDftRealImaginaryToRealImaginary </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Re2Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Im2Im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the inverse DFT of a complex signal. Computes the inverse DFT of a complex signal given in (real, imaginary) representation and returns a (real, imaginary) representation.</p>
<p>The origin is at index [0]. The highest coordinate (SignalLength-2)/2 is at index [(SignalLength-2)/2] for SignalLength even. The highest coordinate (SignalLength-1)/2 is at index [(SignalLength-1)/2] for SignalLength odd. The lowest coordinate -SignalLength/2 is at index [SignalLength/2] for SignalLength even. The lowest coordinate -(SignalLength-1)/2 is at index [(SignalLength+1)/2] for SignalLength odd. The coordinate -1 is at index [SignalLength-1] for SignalLength even or odd.</p>
<p>No restriction on SignalLength, but best efficiency for radix 2, 3, 4, 5. In the explanations above, SignalLength has to be replaced by Nx, Ny, Nz. Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>In-place processing. The input signal (real Re2Re and imaginary Im2Im) is replaced by the output signal (real Re2Re and imaginary Im2Ph).</p>
<p>success: return(!ERROR); failure: return(ERROR); The returned value is duplicated in Status </p>

</div>
</div>
<a class="anchor" id="gafd5c4d3b70b30ae0ec73f8dcfef05437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VolumeRealImaginaryToAmplitudePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Re2Am</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Im2Ph</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Volume Real/Imaginary &ndash;&gt; Amplitude/Phase. Converts a (real, imaginary) representation of a complex signal into an (amplitude, phase) representation. The output phase is in [rad]; its domain is (-PI, PI).</p>
<p>In-place processing. The input signal (real Re2Am and imaginary Im2Ph) is replaced by the output signal (amplitude Re2Am and phase Im2Ph).</p>
<p>Nx is the width of the volume. Ny is the height of the volume. Nz is the depth of the volume.</p>
<p>success: return(!ERROR); failure: return(ERROR); </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
