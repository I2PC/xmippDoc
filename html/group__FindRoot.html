<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Xmipp: Find root</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xmipp_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xmipp
   &#160;<span id="projectnumber">v20.07</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Find root</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7e378201892bf8970518d567355bea1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FindRoot.html#ga7e378201892bf8970518d567355bea1e">RootBracket</a> (int(*Function)(double, void *, double *), void *AuxilliaryData, double *LowerBound, double *UpperBound, double *LowerSample, double *UpperSample, double Tolerance, int *ValidBracket, int *Status)</td></tr>
<tr class="separator:ga7e378201892bf8970518d567355bea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd984fbffcf137be0d19c97d057bcf06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FindRoot.html#gafd984fbffcf137be0d19c97d057bcf06">RootFindBisection</a> (int(*Function)(double, void *, double *), void *AuxilliaryData, double *Root, double LowerBound, double UpperBound, double Tolerance, int *Status)</td></tr>
<tr class="separator:gafd984fbffcf137be0d19c97d057bcf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd2e20c636b0d4e711d5188403697e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FindRoot.html#gaebd2e20c636b0d4e711d5188403697e8">RootFindBrent</a> (int(*Function)(double, void *, double *), void *AuxilliaryData, double *Root, double LowerBound, double UpperBound, double Tolerance, int *Status)</td></tr>
<tr class="separator:gaebd2e20c636b0d4e711d5188403697e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7e378201892bf8970518d567355bea1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RootBracket </td>
          <td>(</td>
          <td class="paramtype">int(*)(double, void *, double *)&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>AuxilliaryData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>UpperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LowerSample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>UpperSample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ValidBracket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find root by bracketing. Bracketing of a root of (Function) inside the interval [LowerBound, UpperBound]. The purpose is to search for a pair of arguments for which 'Function' differs in sign. The search is conducted within [LowerBound, UpperBound]. At most [(UpperBound - LowerBound) / Tolerance] function evaluations are performed. Even-order roots cannot be bracketed. The evaluation of Function at LowerBound (UpperBound) is returned in LowerSample (UpperSample)</p>
<p>success: return(!ERROR); failure: return(ERROR)</p>
<p>the function 'Function' must be declared as follows: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;extern int myFunction(double myArgument, void *AuxilliaryData, double *myResult);</div></div><!-- fragment --><p> It must return ERROR upon failure, and !ERROR upon success</p>
<p>It is evaluated for the value of the variable 'myArgument'. The result of the function evaluation must be returned in 'myResult'. The generic pointer 'AuxilliaryData' can be used to pass additional parameters.</p>
<p>What follows is a developed example of the function f(x) = a * x^2 + b * x + c (a, b, and c are free parameters)</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct myStruct {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   double a, b, c;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;extern int myFunction (</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   double  myArgument,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   void    *AuxilliaryData,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   double  *myResult) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   struct myStruct myData;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   myData = *((struct myStruct *)AuxilliaryData);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   *myResult = myArgument * (myArgument * myData.a + myData.b) + myData.c;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   return(!ERROR);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;int main() {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   struct myStruct myData;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   double LowerBound = -100.0, UpperBound = 100.0;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   double LowerSample, UpperSample;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   double Tolerance = FLT_EPSILON;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   int    ValidBracket;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   int    Status;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   myData.a = 1.0;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   myData.b = 5.0;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   myData.c = 4.0;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   RootBracket(*myFunction, (void *)&amp;myData, &amp;LowerBound, &amp;UpperBound,</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      &amp;LowerSample, &amp;UpperSample, Tolerance, &amp;ValidBracket, &amp;Status);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;   return(0);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gafd984fbffcf137be0d19c97d057bcf06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RootFindBisection </td>
          <td>(</td>
          <td class="paramtype">int(*)(double, void *, double *)&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>AuxilliaryData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>LowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>UpperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a root by bisection. Search for a root of (Function) inside the bracketing interval [LowerBound, UpperBound]. The strategy proceeds by iteratively cutting the interval in two equal parts. Even-order roots generally cannot be found. Only one root is returned, even if there are several ones. Tolerance is relative to the size of the bracketing interval</p>
<p>success: return(!ERROR); failure: return(ERROR)</p>
<p>The function 'Function' must be declared as follows: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;extern int myFunction(double myArgument, void *AuxilliaryData, double *myResult);</div></div><!-- fragment --><p> It must return ERROR upon failure, and !ERROR upon success. It is evaluated for the value of the variable 'myArgument'. The result of the function evaluation must be returned in 'myResult'. The generic pointer 'AuxilliaryData' can be used to pass additional parameters.</p>
<p>What follows is a developed example of the function f(x) = a * x^2 + b * x + c (a, b, and c are free parameters) </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct myStruct {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   double a, b, c;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;extern int myFunction (</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   double  myArgument,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   void    *AuxilliaryData,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   double  *myResult) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   struct myStruct myData;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   myData = *((struct myStruct *)AuxilliaryData);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   *myResult = myArgument * (myArgument * myData.a + myData.b) + myData.c;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   return(!ERROR);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;int main() {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   struct myStruct myData;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   double LowerBound = -100.0, UpperBound = 100.0;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   double Root;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   double Tolerance = FLT_EPSILON;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   int    Status;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   myData.a = 1.0;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   myData.b = 5.0;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   myData.c = 4.0;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   RootBracket(*myFunction, (void *)&amp;myData, &amp;LowerBound, &amp;UpperBound, Tolerance, &amp;Status);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   RootFindBisection(*myFunction, (void *)&amp;myData, &amp;Root, LowerBound,</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      UpperBound, Tolerance, &amp;Status);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;   return(0);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaebd2e20c636b0d4e711d5188403697e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RootFindBrent </td>
          <td>(</td>
          <td class="paramtype">int(*)(double, void *, double *)&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>AuxilliaryData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>LowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>UpperBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find root using Brent algorithm. Search for a root of (Function) inside the bracketing interval [LowerBound, UpperBound]. The strategy proceeds by fitting an inverse quadratic function and by using the root that belong to the interval. If any even-order roots generally cannot be found. Only one root is returned, even if there are several ones. Tolerance is relative to the size of the bracketing interval.</p>
<p>success: return(!ERROR); failure: return(ERROR)</p>
<p>The function 'Function' must be declared as follows: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;extern int myFunction(double myArgument, void *AuxilliaryData, double *myResult);</div></div><!-- fragment --><p>It must return ERROR upon failure, and !ERROR upon success. It is evaluated for the value of the variable 'myArgument'. The result of the function evaluation must be returned in 'myResult'. The generic pointer 'AuxilliaryData' can be used to pass additional parameters.</p>
<p>What follows is a developed example of the function f(x) = a * x^2 + b * x + c (a, b, and c are free parameters) </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct myStruct {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   double a, b, c;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;extern int myFunction (</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   double  myArgument,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   void    *AuxilliaryData,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   double  *myResult) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   struct myStruct myData;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   myData = *((struct myStruct *)AuxilliaryData);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   *myResult = myArgument * (myArgument * myData.a + myData.b) + myData.c;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;   return(!ERROR);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;int main() {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   struct myStruct myData;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   double LowerBound = -100.0, UpperBound = 100.0;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;   double Root;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   double Tolerance = FLT_EPSILON;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;   int    Status;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   myData.a = 1.0;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   myData.b = 5.0;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   myData.c = 4.0;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   RootBracket(*myFunction, (void *)&amp;myData, &amp;LowerBound, &amp;UpperBound, Tolerance, &amp;Status);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   RootFindBisection(*myFunction, (void *)&amp;myData, &amp;Root, LowerBound,</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      UpperBound, Tolerance, &amp;Status);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;   return(0);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
